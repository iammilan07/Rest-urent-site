name: Vault Secret Access
on:
  push:
    branches:
      - main

jobs:
  access-vault-secret:
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Required for OIDC/JWT authentication
      contents: read
    
    steps:
      # Step 1: Login to Vault using the OIDC token
      - name: Vault Login via OIDC
        id: vault_login
        uses: hashicorp/vault-action@v3 # Use the official action
        with:
          url: ${{ secrets.VAULT_ADDR }} # Your Vault server URL (e.g., https://myvault.example.com)
          method: jwt
          path: jwt-github # Must match your vault_jwt_auth_backend path
          role: rigohr-github-test-role # Must match your vault_jwt_auth_backend_role name
          jwt: ${{ secrets.ACTIONS_ID_TOKEN_REQUEST_URL }} # The action automatically exchanges this for the JWT token
          
      # Step 2: Read the secret and inject it as an environment variable
      - name: Read Secret and Set Env Var
        id: read_secret
        uses: hashicorp/vault-action/read@v3
        with:
          url: ${{ secrets.VAULT_ADDR }}
          path: kvv2/github/test # Your secret path
          format: json # To get the data keys/values
          # Assign the secret value 'test' to an environment variable named MY_PASSWORD
          # Note: The data lives under the 'data' key in KV v2.
          exportEnv: |
            MY_PASSWORD: .data.data.test 

      # Step 3: Use the secret (and mask it in the logs)
      - name: Use the Secret
        run: |
          echo "::add-mask::${{ env.MY_PASSWORD }}" # Mask the secret in logs
          echo "The secret (masked) is now available as an environment variable."
          # DO NOT directly echo the secret value in logs in a real workflow.
          # Example of a secure usage:
          # your-application-command --password="${{ env.MY_PASSWORD }}"